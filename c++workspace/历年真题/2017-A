一、简答题：
1、常用有几种循环方法，他们各自有什么特点
答：常用三种循环方法，分别是 while,do...while,for.
    特点：
      while:其结构为while(条件){代码块}，即条件如果成立就执行代码快，每次都必须先判断条件，条件不符合，一次都不执行。
      do...while:结构为do{代码块}while(条件)，第一次执行时，先执行代码快，后判断条件，如果条件不符合，最少也能执行一次。
      for:结构为for(语句1;语句2;语句3){代码块},第一次先执行语句一，初始化控制变量，在执行语句二进行判断，然后执行代码块，
      在执行语句三，变化控制变量，在执行语句二进行判断，判断通过指向代码快，判断不通过跳出循环。
2、当一个表达式同时包含整型，实型和字符型数据，其混合运算的规则是什么？
答：混合运算的规则：
      混合运算时，会自动进行变量转换，比如整型与实型运算时，会自动转化为double的类型进行计算，而字符串则会自动转化为ascii码来进行混合运算
二、程序阅读题
1、
#include<stdio.h>
void inv(int x[],int n){
  int t,i,j;
  for(i=0;i<n/2;i++){
    j=n-1-i;
    t=x[i];
    x[i]=x[j];
    x[j]=t;
  }
}
int main(){
  int i,a[5]={3,7,9,11,0};
  inv(a,5);
  for(i=0;i<5;i++){
    printf("%d ",a[i]);
  }
  printf("\n");
  return 0;
}

程序运行后输出的结果为：0,11,9,7,3
(错)2、
#include<stdio.h>
void main(){
  int a,b[10],c,i=0;
  printf("请输入一个整数：\n");
  scanf("%d",&a);
  while(a!=0){
    c=a%2;
    a=a/2;
    b[i]=c;
    i++;
  }
  for(;i>0;i--){
    printf("%d",b[i-1]);
  }
}
程序运行后，输入数字5，则输出的结果为：1,0,1
注：最后输出时b[i-1],i++ =3但是没有执行，所以最终i=3.及输出数据i的初始值为3
考点：while循环的使用，%:求余，/:整除的区别
（错）3、
#include<stdio.h>
void main(){
  int k=2,i=2,m;
  m=(k+=i*=k); 			//i=i*k 即i=4,k=k+i,k=6
  printf("%d,%d\n",m,i);
}
程序运行之后输出结果为：8,4 正确结果为6,4
考点：加减乘除的运算顺序，先乘除后加减，同时也要注意。
4、
#include<stdio.h>
void main(){
  int a=15,b=21,m=0;
  switch(a%3){
  case 0:
    m++;
  case 1:
    m++;
    switch(b%2){
    default:
      m++;
    case 0:
      m++;
      break;
    }
  }
  printf("%d\n",m);
}
程序运行后输出的结果为：4
（错）5、
#include<stdio.h>
void main(){
  int x=15;
  while(x>10 && x<50){
    x++;
    if(!(x%3)){
      x++;
      break;
    }
    else 
      continue;
  }
  printf("%d\n",x);
}
程序运行之后的结果为：18正确答案19
注意:不符合条件但还是对x++然后在break,所以尽管是18时不符合条件，但还是会+1.
三、根据流程图写程序
1、有一个mxn的矩阵，要求根据下面流程图写出程序来求出其中最大的那个元素的值，以及所在的行号个列号
#include<stdio.h>
int max_value(int a[m][n]){
  int max = a[0][0],i,j,row,column;
  for(i=0;i<m;i++){
    for(j=0;j<n;j++){
      if(a[i][j]>max){
        max=a[i][j];
        row=i;
        column=j;
      }
    }
  }
  printf("output:%d,%d and %d",max,row,column);
}
四、程序填空
1、输入两个整数，求他们的最大公约数和最小公倍数
#include"stdio.h"
#include"conio.h"
void main(){
  int a,b,num1,num2,temp;
  printf("请输入两个整数：\n");
  scanf("%d,%d",&num1,&num2); 1
  if(num1<num2){//交换两个数，使最大数放在num1上
    temp=num1;
    num1=num2;
    num2=temp;
  }
  a=num1;b=num2;
  while(b!=0){ //利用辗除法，直到b=0为止
    temp=a%b;   2
    a=b;        3
    b=temp;     4
  }
  printf("最大公约数是：%d\n",a);
  printf("最小公倍数是:%d\n",num1*num2/a);
}
填空 1:scanf("%d,%d",&num1,&num2); 2:temp=a%b; 3:a=b; 4:b=temp;
(错)2、如果一个数恰好等于他所有因子之和，这个数就称为“完数”，例如：6=1+2+3，编写程序找出1000一内所有的完数。
#include"stdio.h"
#include"conio.h"
void main(void){
  int i,j,k;
  for(j=2;j<1000;j++){
    s=j;
    for(i=0;i<j;i++){    1
      if(k+=i != k*=i){  2
        continue;        3
      }
    }
    if(s==0)
      printf("%d is a wanshu\n",j);
  }
}
填空 1:i=1;i<j;i++ 2:(j%i)==0 3:k=k+i
总结:
考题出处：第五章习题9
3.猴子吃桃的问题，猴子第一天摘下若干个桃子，当即吃了一半还不过瘾，有多吃了一个，
第二天早上又将剩下的桃子吃了一半，又多吃一个，以后每天早上都吃了前一天剩下的一半零一个，
到第10天早上在吃时，见只剩下一个桃子了，求第一天一共摘了多少
提示：采取逆向思维的方法，从后往前推断。
#include"stdio.h"
#include"conio.h"
void main(void){
  int day,x1,x2;
  day=9;
  x2=1;
  while(day>0){
    x1=2*x2+1;  1
    x2=x1;      2
    day--;      3
  }
  printf("the total is %d\n",x1);
}
填空 （错）1:x1=(x2+1)*2  2:x2=x1  3:day--
五、程序设计题
1、编写程序打印出100-999之间所有的‘水仙花数’，所谓“水仙花数”是指一个三位数，其各位数字的立方和等于该数本身，
例如：153是一个“水仙花数”，因为153=1的三次方+5的三次方+3的三次方。
#include<stdio.h>
#include<math.h>
int main(){
    /*
     * 一个三位数，这个数的每位数的立方，和=该位数
     * /:整除   %：取余
     */
    int n=100,i,j,k;
    for(;n<=1000;n++){
	i=n/100;		//获取百位数字
(错)	j=n/10-i*10;		//获取十位数字
	k=n%10;			//获取各位数字
	if(n==i*i*i+j*j*j+k*k*k)//判断他们相等即为水仙花数
	    printf("%d\n",n);
    }
    return 0;
}

2、设计一个程序，计算序列：2/1,3/2,5/3,8/5,13/8,21/13前20项之和。
#include<stdio.h>
int main(){
  //定义分子，分母，总和，i
  int a=2,b=1,i,t;
  float sum;
  for(i=0;i<20;i++){
    sum += a/b;
    t=a;
    a=a+b;
    b=t;
  }
  printf("前20项之和为：%.2f",sum);
  return 0;
}
总结：思路对，但问题出：换值有问题，任何换值都需要使用中间变量temp进行。
3、编写程序，实现从键盘输入10个数，并用选择法从大到小排序。
简单选择排序的基本思想，第1趟在待排序记录r[1]-r[n]中选出最小的记录，将它与r[1]进行交换
第2趟，在待排序的r[2]-r[n]中选择最小的记录，将它与r[2]交换，以此类推，
第i趟在待排序记录r[i]-r[n]中选出最小的记录，与r[i]交换，使得有序数列不断增长直到全部排序完毕。
#include<stdio.h>
int main(){
  //定义变量
  int i a[10],min,temp;
  //用户输入数据
  for(i=0;i<10;i++){
    printf("please enter integer:\n");
    scanf("%d",&a[i]);
  }
  min =a[0];
  for(i=0;i<10;i++){
    if(a[i]>max){
      temp=max;
      max=a[i];
      a[i]=temp;
    }
  }
  //排序后输出
  for(i=0;i<10;i++){
    pritnf("%d",a[i]);
  }
  return 0;
}
正确：
#include<stdio.h>
int main(){
    /*
     * 假定一个小的数，然后与之比较，然后进行跟换下标
     */
    int a[10]={1,2,3,5,6,7,4,9,8,12};
    int min,mid;
    for(int i=0;i<10;i++){
	min = i;
	for(int j=i+1;j<10;j++){
	    if(a[min]>a[j]){		//自定义的a[min]与二轮循环的a[j]进行比较，如果大就交换下标
		min=j;			//先进行下标交换
		mid=a[i];		//再交换值
		a[i]=a[j];
		a[j]=mid;
	    }
	}
    }
    // 输出排序之后的结果
    for(int i=0;i<10;i++){
	printf(" %d",a[i]);
    }
    return 0;
}























